# CareOn 프로젝트 데이터베이스 스키마 설계안

CareOn 프로젝트의 **상품**, **패키지**, **고객**, **직원** 테이블을 신규로 설계하여 Supabase(PostgreSQL) 기반 DB와 연동 가능한 구조를 제안합니다. 전체적으로 **중복 데이터를 줄이고**, **패키지/상품 조합과 가격정책**을 유연하게 지원하며, **관리 페이지(/manage)**에서 실무자가 이해하기 쉽고 관리하기 편하도록 **필드명과 구조를 직관적**으로 구성했습니다. 또한 **계약(Contract) 테이블**과 자연스럽게 연결되도록 외래키 관계를 설정하고, **AI OCR 기반 서류 정보 자동입력** 기능까지 고려한 방안을 포함합니다. 아래에 각 테이블의 상세 설계, 테이블 간 관계, 개선 포인트 및 AI 연동 방안을 정리합니다.

## 상품 (Product) 테이블 설계

**상품 테이블**은 CareOn이 제공하는 개별 서비스 **상품 또는 장비** 정보를 관리합니다. 인터넷 요금제, CCTV 카메라, POS 단말기, 테이블오더 솔루션, 보험 등 **모든 구성 요소를 하나의 목록으로 통합**하여 관리하므로, 새로운 상품이 추가되어도 테이블 구조 변경 없이 데이터를 확장할 수 있습니다. 관리화면에서는 이 테이블의 데이터를 기반으로 **상품 목록을 조회/편집**하고, 패키지 구성 시 선택할 수 있습니다.

상품 테이블의 설계는 다음과 같습니다:

| 필드명 | 자료형 | 설명 |
| :---- | :---- | :---- |
| **product\_id** | UUID (PK) | 상품 고유 ID (Primary Key) |
| **name** | VARCHAR(100) | 상품명 (예: "KT AI CCTV 1대", "500M 인터넷") |
| **category** | VARCHAR(50) | 상품 종류 (예: "인터넷", "CCTV", "POS", "테이블오더", "보험") |
| **provider** | VARCHAR(100) | 공급사/브랜드 (예: "KT텔레캅", "SKB" 등) |
| **monthly\_fee** | INTEGER | 해당 상품의 월 요금 (원) *(기본값 또는 단품 가격)* |
| **description** | TEXT | 상품 설명 및 세부 정보 (UI 표시용 상세내용) |
| **available** | BOOLEAN | 판매/제공 가능 여부 (관리자가 상품 활성/비활성) |
| **closure\_refund\_rate** | INTEGER | 폐업 환급율(%) *(보험 상품의 경우 해당 보험의 폐업 시 환급 비율)* |
| **created\_at** | TIMESTAMP | 생성 일시 (기본값: 현재시간) |
| **updated\_at** | TIMESTAMP | 수정 일시 (자동 업데이트) |

* **PK**: product\_id는 UUID로 생성하여 고유 식별자로 사용합니다.

* **상품명(name)**과 **종류(category)**를 분리하여, 관리 UI에서 종류별로 필터링하거나 그룹화할 수 있습니다. 예를 들어 "인터넷" 카테고리의 상품들(100M, 500M 요금제 등)만 조회하는 식의 관리가 가능합니다.

* **monthly\_fee**: 상품별 기본 월납 요금을 명시합니다. 패키지에 포함되어 할인되거나 1년 무료인 경우라도, **기본값**으로서 저장해두고 계약/패키지에서 별도 할인이나 무료기간을 적용할 수 있습니다. (예: 500M 인터넷 상품 monthly\_fee=33000원, CCTV 1대 monthly\_fee=??원 등)

* **closure\_refund\_rate**: 보험 상품에 한해 폐업 시 **환급율**을 명시합니다. 예를 들어 "한화 안심커버300" 보험 상품의 환급율 100%, "안심커버1000" 보험 상품 100% 등으로 설정하여, 해당 상품이 포함된 계약에서 폐업 발생 시 환급 정책을 알 수 있습니다. *(일반 상품에는 NULL 또는 0으로 둡니다.)*

* **description**: 예비 창업자나 관리자가 상품 세부 내용을 볼 수 있도록 합니다. (예: *"KT AI CCTV: AI 분석 기능 포함, 36개월 약정"* 같은 설명)

* **available**: 상품을 단종시키거나 임시 제외할 때 false로 변경하여 **UI에 노출되지 않도록** 할 수 있습니다.

**예시:** 상품 테이블에 "SKB 초고속인터넷 500M" (카테고리: 인터넷, provider: SK브로드밴드, monthly\_fee: 41800원 등), "KT AI CCTV" (카테고리: CCTV, provider: KT텔레캅, monthly\_fee: 45200원 등), "토스 POS 세트" (카테고리: POS, provider: 토스페이먼츠, monthly\_fee: 0원 또는 일정 비용), "한화 안심커버300 보험" (카테고리: 보험, provider: 한화, monthly\_fee: 보험료, closure\_refund\_rate: 100\) 등의 항목들이 등록될 수 있습니다. 관리자는 이 목록을 보고 신규 상품을 추가하거나 수정할 수 있습니다.

## 패키지 (Package) 테이블 설계

**패키지 테이블**은 여러 상품을 묶어 만든 **패키지 상품/요금제** 정보를 관리합니다. CareOn에서 제공하는 **스타트케어 패키지**(미니, 프로 등)와 같이 **정형화된 조합**을 하나의 엔트리로 저장하며, 패키지별 **월합산 요금, 계약기간, 무료기간, 혜택** 등을 명시합니다. 이를 통해 관리자는 패키지를 쉽게 추가/변경하고, 계약 시 고객에게 **표준화된 견적**을 제공할 수 있습니다.

패키지 테이블의 설계는 다음과 같습니다:

| 필드명 | 자료형 | 설명 |
| :---- | :---- | :---- |
| **package\_id** | UUID (PK) | 패키지 고유 ID (Primary Key) |
| **name** | VARCHAR(100) | 패키지명 (예: "스타트케어 미니", "스타트케어 PRO") |
| **monthly\_fee** | INTEGER | 패키지 기준 월 요금 (원) |
| **contract\_period** | INTEGER | 계약 기간 (개월) *예: 36 (3년)* |
| **free\_period** | INTEGER | 무료 제공 기간 (개월) *예: 12 (1년)* |
| **closure\_refund\_rate** | INTEGER | 폐업 보험 환급율 (%) *해당 패키지 적용 보험 기준* |
| **included\_services** | TEXT | 부가 서비스 내용 설명 *(패키지에 포함된 특별 제공 서비스)* |
| **description** | TEXT | 패키지 설명 (패키지 구성 요약/특징) |
| **active** | BOOLEAN | 판매 중 여부 (false면 해당 패키지 비노출) |
| **created\_at** | TIMESTAMP | 생성 일시 (기본값: 현재시간) |
| **updated\_at** | TIMESTAMP | 수정 일시 (자동 업데이트) |

* **monthly\_fee**: 해당 패키지의 **월 납부 금액**을 명시합니다. 예를 들어 "스타트케어 미니" 패키지의 월 요금 45,000원, "PRO" 패키지 월 94,500원 등. 이 금액은 *무료기간 종료 후 적용되는 정상 월 요금* 기준이며, 무료기간 동안은 별도 로직으로 0원 처리합니다. (관리자 UI에서는 패키지별로 1년 계약 시/3년 계약 시 총액도 참고로 보여줄 수 있지만, DB에는 굳이 저장하지 않고 계산으로 처리 가능함.)

* **contract\_period, free\_period**: 계약 총 기간과 그 중 무료로 제공하는 기간을 명시합니다. 위 예시의 이벤트 패키지처럼 *36개월 약정에 12개월 무료*일 경우 contract\_period=36, free\_period=12로 설정합니다. 이 정보는 견적 계산과 계약서 출력 시 사용됩니다.

* **closure\_refund\_rate**: 해당 패키지에 포함된 폐업보험의 환급율을 명시합니다. 패키지 설계 시 *폐업보험이 포함된 경우* 그 보험 상품의 환급율을 패키지에 명기해두면, 계약 조건 설명시에 "**폐업 시 납입금의 100% 환급**" 등의 문구를 쉽게 표시할 수 있습니다. (예: 미니=100%, 프로=100%, 어떤 패키지는 90% 등)

* **included\_services**: 패키지 구매 고객에게 제공되는 **부가 서비스**를 서술합니다. 예를 들어 "출장 무료설치, 배달앱(배민) 및 네이버 등록 대행"과 같이 해당 패키지에 딸린 서비스 혜택을 기록합니다. 이것은 관리페이지/UI에 패키지의 부가혜택을 표시하거나, 추후 **실무자가 작업해야 할 항목**으로 참고하기 위함입니다.

* **description**: 패키지 구성에 대한 요약이나 타겟 고객, 특징 등을 기술할 수 있습니다. (예: "*예비 창업자 대상 최소비용 패키지 \- 셀프설치 방식*", "*고급형 패키지 \- 장비 최대 제공*" 등)

* **active**: 단종이나 판매중지된 패키지는 false로 처리하여 관리 UI와 계약 신청 페이지 등에 노출되지 않도록 합니다.

**패키지 구성 상품 관계:** 개별 패키지가 구체적으로 **어떤 상품들을 포함**하는지 표현하기 위해 **패키지-상품 연결 테이블**이 필요합니다. 이 테이블을 통해 패키지별 구성품 목록과 수량을 관리합니다. 예를 들어 "스타트케어 PRO" 패키지는 갤럭시탭 1개, 토스 카드단말기 1개, KT AI CCTV 6대, 인터넷 (1Gbps) 1라인, 인터넷전화 1라인, 한화 안심커버1000 보험 1건 등 여러 상품으로 이루어지므로, 아래와 같은 연결 테이블에 다수의 레코드로 저장됩니다.

### 패키지구성 (PackageItems) 테이블 설계

| 필드명 | 자료형 | 설명 |
| :---- | :---- | :---- |
| **package\_id** | UUID FK | 패키지 ID (Packages 테이블 참조) |
| **product\_id** | UUID FK | 상품 ID (Products 테이블 참조) |
| **quantity** | INTEGER | 포함 수량 (해당 상품을 몇 개 포함하는지) |
| **item\_fee** | INTEGER | 해당 아이템의 패키지 내 할당 요금(원) *(선택사항: 패키지 할인 등으로 개별 단가 조정 시)* |

* PackageItems 테이블의 (package\_id, product\_id) 복합키로 각 상품이 어떤 패키지에 몇 개 포함되는지 정의합니다.

* **quantity**: CCTV처럼 여러 대 제공되는 경우 수량으로 관리합니다. (예: PRO 패키지의 CCTV quantity=6). 수량 1인 항목도 명시적으로 1로 저장합니다.

* **item\_fee**: 패키지 내에서 해당 상품에 책정된 요금입니다. 기본적으로 각 상품의 monthly\_fee를 기반으로 하지만, 패키지 할인이나 조정이 있다면 그 반영된 금액을 넣을 수 있습니다. *(예: 패키지 할인으로 특정 상품을 무료로 포함시키는 경우 item\_fee=0으로 기재. 이 필드는 옵션이며, 별도 관리 필요 없으면 NULL 또는 상품 기본값으로 일괄처리합니다.)*

패키지-상품 연결 구조를 활용하면, **관리자 UI에서 패키지 생성/수정 시 체크박스나 드롭다운으로 상품들을 선택하고 수량을 입력**하여 구성할 수 있습니다. 또한 패키지 상세화면에서 자동으로 포함 상품 목록을 불러와 보여줄 수 있어 관리 효율이 높아집니다.

**예시:** 패키지 "스타트케어 미니"의 구성은 PackageItems에 다음과 같이 저장됩니다: KT AI CCTV(product\_id=...) 1대, SKB 100M 인터넷 1개, 매장 인터넷전화 1개, 갤럭시탭 1개, 토스프론트(키오스크 앱) 1개, (IPTV 없음), (보험 없음). 패키지 "스타트케어 PRO"는 CCTV 6대, SKB 1Gb 인터넷 1개, 인터넷전화 1개, 갤럭시탭 1개, 토스터미널 1개, 한화 안심커버1000 보험 1건 등으로 저장됩니다. 이렇게 **패키지 구성 정보가 구조화**되면, 계약서나 견적서에 자동으로 "포함내역"을 표시하거나 변경사항을 일괄 반영하기 쉽습니다.

## 고객 (Customer) 테이블 설계

**고객 테이블**은 **가맹점(고객사) 정보**를 관리하는 테이블입니다. 기존에는 계약 테이블에 사업장 이름, 대표자, 연락처 등을 직접 저장했으나, 이를 분리함으로써 **여러 계약에 동일 고객정보를 재사용**하거나 고객 정보 변경 시 일관성 있게 업데이트할 수 있습니다. 또한 사업자등록증 등 **서류 OCR로 추출한 정보**를 저장하는 주 대상이 됩니다. 고객 테이블에는 사업체일 경우 상호/대표자 등을, 개인사업자나 개인 고객일 경우 본인 이름 등을 저장하며, 계약 시 필요한 핵심 정보들을 모두 포함합니다.

고객 테이블의 설계는 다음과 같습니다:

| 필드명 | 자료형 | 설명 |
| :---- | :---- | :---- |
| **customer\_id** | UUID (PK) | 고객 고유 ID (Primary Key) |
| **customer\_code** | VARCHAR(20) | 고객번호 코드 *(예: "CO202309100001" 형태로 자동생성)* |
| **business\_name** | VARCHAR(200) | 사업장 상호 (고객명) |
| **owner\_name** | VARCHAR(100) | 대표자 이름 (개인사업자일 경우 본인 이름) |
| **business\_registration** | VARCHAR(20) | 사업자등록번호 (또는 주민/법인번호) |
| **phone** | VARCHAR(20) | 고객 연락처 전화번호 (대표번호) |
| **email** | VARCHAR(255) | 이메일 주소 |
| **address** | TEXT | 사업장 주소 |
| **industry** | VARCHAR(100) | 업종/업태 *(예: 요식업, 서비스업 등)* |
| **status** | VARCHAR(20) | 상태 (예: "active", "inactive") |
| **created\_at** | TIMESTAMP | 생성 일시 |
| **updated\_at** | TIMESTAMP | 수정 일시 |

* **customer\_code**: 사람이 읽기 쉬운 **고객 식별코드**로, CO 접두어와 일련번호/일자를 조합하여 자동 생성합니다. 예를 들어 첫 번째 고객은 CO202309100001 형태로 발급하여, 관리자가 계약 목록을 볼 때 고객을 코드로 빠르게 식별하거나, 고객을 레퍼런스할 때 편리하게 합니다.

* **business\_name, owner\_name**: 각각 **상호명**과 **대표자 성명**을 저장합니다. 만약 개인 고객이라면 business\_name에 본인 이름 또는 업체명이 없으면 개인 이름을 넣고, owner\_name도 동일하게 개인 이름을 넣을 수 있습니다. (필요시 개인/법인 구분 필드를 추가할 수 있지만 기본 시나리오에서는 생략)

* **business\_registration**: 사업자등록번호 10자리 (또는 법인번호), 개인 고객의 경우 주민등록번호 대신 신분증 확인만 하고 저장은 하지 않을 수도 있습니다. 이 필드는 **OCR로 사업자등록증을 스캔하여 자동 입력**되며, 계약서에는 필수항목으로 활용됩니다.

* **industry**: 해당 고객의 업종이나 카테고리를 기록해둘 수 있습니다. 예를 들어 UI에서 **요식업(F\&B)**으로 분류된 고객에게는 테이블오더 옵션을 추천하거나, 업종별 통계 등을 낼 때 활용할 수 있습니다.

* **status**: 'active'(활동 중), 'inactive'(휴면/탈퇴) 등으로 고객상태를 관리합니다. 기본값은 active이며, 계약이 모두 종료된 고객은 inactive로 전환 가능 etc. (관리용)

* **phone, email, address**: 연락 가능한 대표 전화번호, 이메일, 사업장 소재지 주소를 저장합니다. **관리 페이지에서 해당 정보를 수정**하거나 **계약 진행 시 자동 채움(auto-fill)** 하는 데 사용합니다.

고객 테이블 도입으로, 계약 테이블에는 고객을 **참조(FK)**만 하고 상세 정보는 여기서 조회하게 됩니다. 예를 들어 관리자가 /manage에서 고객 목록을 관리할 수 있고, 신규 계약을 생성할 때 **기존 고객을 검색/선택**하거나 **새 고객을 추가**하는 UX가 가능해집니다. 또한 한 고객이 **다수의 계약(지점 또는 추가 서비스 계약)을 체결**하는 경우에도 고객 정보의 일관성을 유지할 수 있습니다.

## 직원 (Employee) 테이블 설계

**직원 테이블**은 CareOn 내부 운영진 또는 영업 담당자 등 **시스템을 사용하는 직원 계정** 정보를 관리합니다. 관리페이지 접근 권한을 부여하거나, **각 계약에 담당자를 지정**하고 추적하기 위해 필요합니다. 기존 계약 테이블의 processed\_by 필드가 단순 이름 문자열이라 추후 혼동이나 변경시 이력 추적이 어려우므로, 이를 직원 테이블로 대체하여 **정규화**합니다.

직원 테이블의 설계는 다음과 같습니다:

| 필드명 | 자료형 | 설명 |
| :---- | :---- | :---- |
| **employee\_id** | UUID (PK) | 직원 고유 ID (Primary Key) |
| **name** | VARCHAR(100) | 직원 이름 |
| **role** | VARCHAR(50) | 역할/직책 (예: "관리자", "영업팀", "설치기사") |
| **email** | VARCHAR(100) | 이메일 (계정 로그인 또는 연락처 용도) |
| **phone** | VARCHAR(20) | 연락처 전화번호 |
| **status** | VARCHAR(20) | 상태 ("active", "inactive" 등) |
| **created\_at** | TIMESTAMP | 생성 일시 |
| **updated\_at** | TIMESTAMP | 수정 일시 |

* **name**과 **role**: 직원의 이름과 직무 역할을 기록합니다. 예를 들어 name="홍길동", role="영업담당" 또는 role="관리자" 등으로 저장하여, **계약 처리 담당자**를 지정하거나 **권한 관리**에 활용합니다.

* **email, phone**: 직원별 이메일과 전화번호입니다. 이메일은 Supabase Auth와 연계하여 로그인 ID로 쓸 수도 있고, 또는 단순 참고용으로 둘 수 있습니다. *(만약 별도 인증 체계를 쓰지 않으면 이 테이블에 로그인 비밀번호 해시 등을 추가해 계정 관리 가능)*

* **status**: 직원 계정의 활성여부를 나타냅니다. 퇴사 등의 경우 inactive로 두어 로그인 차단/검색 제외 처리합니다.

관리 UI에서는 직원 계정 생성/권한부여, 담당자 할당 등이 가능해집니다. 예를 들어 계약건마다 담당 직원을 지정하면, 직원 테이블의 employee\_id가 계약 테이블에 기록되어 누가 해당 계약을 처리/관리하는지 명확히 알 수 있습니다. 또한 role 필드를 통해 UI에서 **권한별 기능 제한**(예: 영업팀은 계약 조회/작성만 가능, 관리자는 모두 가능)을 구현할 기반을 제공합니다.

## 계약 테이블과의 연동 및 조인 구조

위에서 설계한 **상품**, **패키지**, **고객**, **직원** 테이블은 기존 **계약(Contract) 테이블**과 밀접히 연동되어 작동합니다. 아래는 **테이블 간 관계(조인 구조)**와 계약 테이블의 변경사항을 정리합니다:

* **고객 1 : N 계약** – **고객(customer)** 테이블과 **계약(contract)** 테이블은 1대다 관계입니다. 하나의 고객이 여러 건의 계약을 맺을 수 있으므로, contracts 테이블에 customer\_id FK를 추가하고 고객의 기본 정보를 참조합니다. 기존 contracts 테이블에 있었던 business\_name, owner\_name, phone, email, address, business\_registration 등의 필드는 **고객 테이블로 이동**하며, 계약 당시의 정보가 필요하면 조인을 통해 가져옵니다. *(필요시 계약에 저장된 스냅샷 필드로 customer\_name 등을 둘 수도 있으나, 일반적으로는 FK 참조로 충분합니다.)*

* **패키지 1 : N 계약** – 고객이 표준 패키지로 계약하는 경우, 계약 테이블이 어떤 패키지를 선택했는지 알 수 있도록 contracts 테이블에 package\_id (FK)를 추가합니다. 이를 통해 계약건이 특정 **패키지 상품을 의미**함을 명시합니다. 다만 고객이 **패키지에 없던 추가상품**을 별도로 요청하거나 커스터마이즈하는 경우가 있으므로, package\_id는 *선택적(optional) FK*로 두고, 값이 NULL이면 **맞춤형 계약**임을 나타낼 수 있습니다.

* **계약 1 : N 계약상품** – 한 계약에 여러 상품이 조합될 수 있으므로, **계약-상품 연결 테이블**을 별도로 둡니다. 예를 들어 고객이 패키지가 아닌 개별 조합으로 인터넷 \+ POS만 계약했다면, 계약ID에 연결된 상품목록으로 인터넷 상품과 POS 상품 두 줄이 기록됩니다. 혹은 패키지를 선택한 계약이라도, *패키지 기본구성 외에 추가 CCTV 2대를 유상 추가*하는 식의 요구에 대응하려면 계약-상품 관계로 관리하는 것이 유연합니다. 이를 위해 **ContractItems(또는 contract\_products)** 테이블을 생성합니다:

**계약상품 (ContractItems) 테이블** – 필드: contract\_id (FK), product\_id (FK), quantity, fee.  
이 구조는 패키지구성(PackageItems)과 유사하며, 특정 계약이 **어떤 상품들을 몇 개씩 포함**하는지 저장합니다. 계약 확정 시 관리자는 이 테이블에 해당 계약의 구성품을 기록하며, **total\_monthly\_fee(총 월 요금)**는 이 계약상품들의 fee 합계로 산출합니다. *(Contract 테이블의 total\_monthly\_fee 필드를 유지하되, 데이터 무결성을 위해 contract\_items를 소스로 계산하여 업데이트)*

* **직원 N : N 계약** – **직원(employee)** 테이블과 **계약(contract)** 테이블은 1대다 관계로 연결됩니다. 계약 처리자나 담당자를 지정하려면, contracts.processed\_by를 기존 텍스트에서 employee\_id (FK)로 변경합니다. 이렇게 하면 계약-\>직원 조인이 가능해져, 예를 들어 **직원별 계약 건수 통계**나 **담당자별 진행상태** 등을 쉽게 조회할 수 있습니다. 또한 processed\_at 필드에 처리 일시를 기록하므로, *어느 직원이 언제 처리했는지* 추적 가능합니다. (추가로 계약에 sales\_rep\_id, installer\_id 등을 둬서 **영업담당자**, **설치담당자**를 분리 관리할 수도 있습니다. 이들도 결국 직원 테이블 참조 FK로 구현합니다.)

* **상품 M : N 패키지** – 앞서 설계한 **PackageItems** 테이블로 **상품-패키지**의 다대다 관계를 관리합니다. 이를 통해 패키지별 포함 상품 정보를 조회하거나, 특정 상품이 들어있는 패키지들을 찾을 수 있습니다. 예를 들어 상품 테이블에서 "KT AI CCTV"를 조회하면서, 어떤 패키지에 몇 대씩 쓰이고 있는지 파악 가능합니다.

* **상품 M : N 계약** – **ContractItems**를 통해 **상품-계약**의 다대다 관계를 관리합니다. 이를 통해 특정 계약의 전체 상품내역을 조회하거나, 반대로 특정 상품이 현재 몇 개의 계약에 사용되고 있는지도 파악할 수 있습니다. (예: "POS 단말기" 상품이 총 몇 건의 계약에 포함되었는지 등)

위 관계를 그림으로 나타내면 **고객 \-\< 계약 \>- 직원**의 형태로 계약이 양쪽을 참조하고, 계약은 또 **패키지 \>-\< 상품**의 구조를 가집니다. **패키지**는 편의상 계약에 직접 연결(FK)하면서 **구성 상품 리스트**는 별도로 가져오고, **맞춤 계약**의 경우 package\_id 없이 **상품 리스트만 존재**하는 형태입니다. 이러한 구조로 인해 **중복 데이터 입력 없이**도 다양한 조합을 표현할 수 있고, 조인으로 필요한 정보를 가져올 수 있습니다:

* 계약 상세보기 시: 계약 \-\> 고객 조인으로 상호/대표자 등 표시, 계약 \-\> ContractItems \-\> 상품 조인으로 인터넷/키오스크 등 구성 품목과 수량, 계약 \-\> 패키지 조인으로 패키지명 및 표준요금 비교, 계약 \-\> 직원 조인으로 담당자 이름 표시… 등의 쿼리가 가능합니다.

* **계약서 생성 시**에도 계약 하나의 모든 필요한 정보를 여러 테이블에서 모아 채울 수 있습니다. 예를 들어 계약서에는 고객 정보(고객테이블), 선택 서비스 목록(상품/패키지테이블), 요금(계약 or 계산된 값), 담당자명(직원테이블) 등이 포함되는데, **정규화된 구조** 덕분에 최신 정보로 반영되며 관리자가 일일이 수기 입력할 필요가 없습니다.

## 스키마 개편에 따른 개선 포인트

제안된 스키마는 **현재 분산된 정보와 중복 필드**들을 통합하고 관계를 명확히 함으로써 여러 가지 개선 효과를 기대할 수 있습니다:

* **1\) 고객 정보 중앙 관리:** 기존에는 계약마다 고객 정보를 중복으로 입력/저장했지만, **고객 테이블** 도입으로 한 번 입력된 고객 데이터를 여러 계약에서 공유합니다. 이를 통해 **오타나 변경 사항을 한 곳에서 수정**할 수 있고, 동일 고객의 추가 계약 시 재입력 없이 자동 참조되어 업무 효율이 높아집니다. (예: 기존 고객이 새로운 지점을 내며 두 번째 계약을 신청하면, 고객 테이블에서 검색하여 바로 연결 가능)

* **2\) 상품/서비스 추가 용이:** 인터넷, CCTV 이외에 POS, 테이블오더 등 **새로운 상품을 추가**할 때 DB 변경 없이 **Product 테이블에 행 추가만으로** 대응 가능합니다. 또한 Contract 테이블에 pos\_needed, tv\_needed 등 **열을 추가하는 방식** 대신, ContractItems에 해당 상품 레코드를 추가하면 되므로 **스키마 변경 없이 서비스 확장**이 가능합니다. 즉, **유연한 상품 조합**을 지원하여 고객 맞춤 견적 요구에 대응할 수 있습니다. 관리페이지에서도 체크박스를 늘리거나 하는 대신 동적으로 상품 목록을 가져와 폼을 생성할 수 있습니다.

* **3\) 패키지 관리 일원화:** 패키지 구성을 더 이상 엑셀에 의존하거나 문서로 기억하지 않고 **DB테이블로 구조화**했으므로, **중복 정보**를 없애고 **단일 출처(Single Source of Truth)**로 관리할 수 있습니다. 예를 들어 "스타트케어 PRO" 패키지에 포함된 CCTV 대수가 6대에서 8대로 변경되면, 엑셀/문서/코드 여러 곳을 수정할 필요 없이 DB의 PackageItems 한 곳만 수정하면 됩니다. 이는 곧 **웹 관리자 페이지에서 실시간 수정**이 가능함을 의미하며, 프런트엔드에서도 해당 데이터를 바로 반영해 계약 신청 화면 등에 표시할 수 있습니다.

* **4\) 계약-상품 데이터 일관성:** 계약 테이블의 각 서비스 요금 필드(internet\_monthly\_fee, cctv\_monthly\_fee 등)를 개별로 관리하던 것을 **계약상품 리스트로 통합**함으로써 데이터의 **일관성과 무결성**이 높아집니다. 예전에는 계약 하나에 인터넷요금, CCTV요금을 따로 입력하면서 총액을 사람이 계산해야 했지만, 이제 **ContractItems 합계로 total\_monthly\_fee를 산출**하므로 누락이나 계산 오류를 방지할 수 있습니다. 또한 계약 항목이 늘어나더라도 (예: 새로운 보험요금) DB컬럼을 추가하는 대신 **상품 추가**만으로 대응 가능하여 유지보수가 쉽습니다.

* **5\) 관리화면(UI) 개선:** 필드명이 현실 용어와 일치하고 참조 관계가 명확해졌기 때문에, 관리페이지에서도 **직관적인 UI/UX**를 구축할 수 있습니다. 예를 들어, 계약 생성 화면에서 **드롭다운으로 고객 선택**, **패키지 선택시 자동으로 포함 상품 리스트 표시**, **추가 상품 체크박스**로 개별 아이템 선택, **담당자 선택** 등 UI 요소를 쉽게 구성할 수 있습니다. 또한 직원 테이블로 권한과 역할을 관리할 수 있으므로, UI에서 **권한별 메뉴 제어**도 가능해집니다. 전체적으로 데이터 구조가 **현실 업무 객체**와 매핑되어 있어 실무자가 사용하기 이해하기 쉽고, 필드 추가/변경 없이 다양한 조합을 다룰 수 있어 **관리 효율성**이 높아집니다.

* **6\) 데이터 분석 및 확장:** 정규화된 스키마를 통해 추후 **데이터 분석이나 리포팅**을 체계적으로 할 수 있습니다. 예를 들어 어떤 상품이 가장 많이 팔렸는지, 어떤 패키지가 인기가 높은지, 고객 업종별로 어떤 조합을 많이 선택하는지 등을 SQL 조인/집계를 통해 손쉽게 뽑아낼 수 있습니다. 이는 향후 비즈니스 전략 수립이나 상품 구성 개편에도 유용한 인사이트를 줄 것입니다.

요약하면, 새로 설계한 스키마는 **중복 제거와 관계 명확화**로 데이터 정합성을 높이고, **상품-패키지-계약의 유연한 연결**로 사용자 맞춤형 기능 구현을 용이하게 하며, **관리자 경험 개선** 및 **향후 확장성**까지 고려한 구조입니다.

## AI 기반 서류 정보 추출 및 자동 매핑 방안

마지막으로, **AI를 활용한 서류 정보 자동 입력** 부분을 설계 차원에서 고려합니다. CareOn 계약 프로세스에서는 고객이 **사업자등록증, 통장사본, 신분증 이미지**를 업로드하면, 이를 바탕으로 계약 필드에 정보를 채워주는 기능이 요구됩니다. 이를 구현하기 위한 방법과 고려사항은 다음과 같습니다:

1. **OCR 기술 활용:** 업로드된 이미지에서 텍스트를 추출하기 위해 **OCR(광학문자인식)** 엔진이나 API를 활용합니다. 예를 들어 **Tesseract OCR** 라이브러리나 **Google Vision API**, 국내 사업자등록증 인식을 잘하는 **NAVER CLOVA OCR** 등을 사용할 수 있습니다. 이 단계에서 서류 종류별로 **적절한 사전처리**를 적용합니다 (예: 사업자등록증은 양식이 정형화되어 있어 특정 영역의 글자를 추출, 통장사본은 계좌번호/은행명 패턴 인식 등).

2. **서류별 추출 필드 매핑:**

3. **사업자등록증**: 상호명, 대표자 성명, 사업자등록번호, 주소 등을 인식합니다. 예를 들어 OCR 결과에서 "상호" 라벨 옆의 텍스트나 숫자 10자리 패턴 등을 찾아냅니다. 이렇게 추출한 데이터는 **고객 테이블의 business\_name, owner\_name, business\_registration, address 필드에 매핑**합니다. (업종/종목 정보도 있다면 industry 필드에 반영 가능)

4. **통장사본**: 은행명, 계좌번호, 예금주명을 인식합니다. 이미지 상에서 일반적으로 은행 로고나 이름, 계좌번호 숫자, 예금주 (한글 이름)가 추출될 것입니다. 이를 기반으로 **계약 테이블의 bank\_name, account\_number, account\_holder 필드**를 자동 채웁니다. (OCR 신뢰도가 낮을 경우 계좌번호 포맷 등으로 2차 검증 로직 추가)

5. **신분증(대표자 신분증)**: 이름, 생년월일, 신분증 번호 등을 인식할 수 있으나, **개인정보 보호 이슈**로 주민번호 등 민감정보는 DB에 저장하지 않는 것이 바람직합니다. 대신 대표자 **이름**(owner\_name 확인용)과 **생년월일**(계약서에 필요한 경우) 정도만 추출합니다. 신분증 이미지로부터 대표자명을 인식해 **고객 테이블의 owner\_name과 대조**하여 일치 여부를 확인하거나 자동 채워 넣을 수 있습니다.

6. **자동 매핑 및 검증:** 추출한 값들은 **적절한 필드에 자동 할당**하되, 사용자(관리자)가 확인할 수 있도록 UI에 보여줍니다. 예컨대 관리 페이지에서 계약 신청을 검토할 때 OCR로 채워진 값들을 편집 가능한 형태로 띄워주고, **잘못 인식된 부분은 수정**할 수 있게 합니다. 특히 숫자 0/O, 1/I 등의 혼동이나 지워진 글자 등 OCR 오류 가능성이 있으므로 **사후 검증 단계**가 필요합니다. (필요시 사업자등록번호 10자리 체크섬 검증 등 룰을 적용)

7. **보안 및 개인정보 고려:** 업로드된 서류 이미지는 **Supabase 스토리지** 등에 안전하게 저장하고, OCR 추출 후에는 필요 시 마스킹하거나 이미지를 삭제하는 등 **개인정보 보호**를 고려합니다. 또한 신분증의 주민등록번호 등 민감 정보는 **저장하지 않고 일회성 검증**에만 사용하거나, 해싱/암호화하여 보관해야 합니다. 해당 기능 구현 시 **개인정보 처리 방침**을 수립하고, 사용자의 동의를 받아야 합니다. (계약 테이블의 terms\_agreed, info\_agreed 필드가 이미 이러한 동의를 명시하는 용도로 존재)

8. **시스템 통합:** OCR로 얻은 데이터를 실제 DB에 넣는 작업은 **백엔드 서버 또는 Cloud Function**에서 수행합니다. 예를 들어 **계약 신청 API**에서 파일을 받아 OCR \-\> 필드추출 \-\> DB에 임시 저장(혹은 바로 계약 생성)까지 자동화합니다. Supabase의 경우 Edge Function이나 외부 서버에서 이 처리를 한 뒤, **contracts 테이블** 및 **customers 테이블**을 업데이트하거나 생성하는 로직을 구현할 수 있습니다.

**고려사항:** OCR 결과가 항상 정확하지 않으므로 **100% 자동보다는 보조 수단**으로 활용하는 것이 현실적입니다. 관리자는 OCR이 채운 내용을 검토/수정한 후 **최종 승인**하게 되고, 그 결과가 DB에 확정적으로 반영됩니다. 이렇게 하면 AI가 반복 학습될 수 있고(패턴 피드백), 관리자 업무도 크게 줄지만, 동시에 **오입력 방지**를 위한 통제도 가능합니다.

예를 들어 사업자등록증에서 **"주식회사 케어온"**, **대표 "홍길동"**, **사업자번호 "123-45-67890"**를 추출했다면, 이를 고객 테이블 신규 레코드에 미리 채워두고 계약 생성 화면에 불러옵니다. 관리자는 원본 이미지와 OCR텍스트를 대조하여 이상이 없으면 그대로 저장하거나, 혹시 잘못된 경우 수정합니다. **통장사본**의 계좌정보도 마찬가지로 자동 기입된 값을 확인만 하면 되도록 하여, **데이터 입력 시간을 단축**시키고 **오류를 감소**시킵니다.

이러한 AI OCR 연동으로 **계약 필드 입력 자동화**를 구현하면, 실무자는 서류에서 숫자와 글자를 일일이 확인해 입력하는 과정을 생략할 수 있어 업무 효율이 향상됩니다. 다만 **OCR 모델의 정확도 향상**, **예외 케이스 처리**(글씨 흐림, 손글씨 등), **보안**에 지속적인 신경을 써야 합니다. 필요하다면 중요 필드는 OCR 두 번 실행 후 결과 비교하거나, 특정 규칙(예: 사업자번호 형태)으로 프로그램matically 검증하여 신뢰도를 높일 수 있습니다.

---

以上がCareOn 프로젝트의 누락 테이블 설계 및 개선 방안에 대한 종합적인 제안입니다. 새로운 스키마를 적용하면 **패키지/상품 관리의 일원화, 데이터 중복 해소, 유연한 고객맞춤 기능, 관리자동화 및 AI연계** 측면에서 큰 이점을 얻을 것으로 기대됩니다. 각 테이블과 기능 설계는 **현장 요구사항**(회의 내용)과 **시스템 구현 용이성**을 균형있게 반영하였으며, 추후 비즈니스 확장에도 견고한 기반이 될 것입니다. 필요한 경우 추가 논의를 통해 세부 필드나 규칙을 조율하면 좋겠습니다. 개발과 운영 과정에서 본 설계안을 활용하여 CareOn 플랫폼을 효율적으로 구축하시길 바랍니다.

---

